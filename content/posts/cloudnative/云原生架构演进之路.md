---
title: "云原生架构演进之路"
date: 2021-09-26T19:43:53+08:00
lastmod: 2021-09-26T19:43:53+08:00
draft: true
keywords: 
 - 架构
 - 理论
featuredImage: "https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210926200427.png"
tags: 
 - 笔记
categories: 
 - 云原生
author: "Lack"
---
## 架构的演进
单体 -> 分布式 -> 微服务 -> 云原生

### 单体架构

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210926200654.png)

特点:
- 所有的功能集成在一个项目工程中。
- 通过部署应用集群和数据库集群来提高系统的性能。

优点:
- 项目架构简单，前期开发成本低，周期短，小型项目的首选。
- 开发效率高，模块之间交互采用本地方法调用。
- 容易部署，运维成本小。
- 容易测试: IDE 都是为开发单个应用设计的，容易测试——在本地就可以启动完整的系统。

缺点:
- 全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。
- 版本迭代速度逐渐变慢，修改一个地方就要将整个应用全部编译、部署、启动，开发及测试周期过长。
- 无法按需伸缩，通过集群的方式来实现水平扩展，无法针对某业务按需伸缩。

> 一个鸡蛋放在一个篮子里。

### 分布式架构

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210926200756.png)

特点:
- 按业务垂直拆分成一个一个的单体系统，此架构也称为垂直架构。
- 系统与系统之间存在数据冗余，耦合性大。
- 系统之间的接口多为实现数据同步。

优点:
- 通过垂直拆分，每个子系统变成小型系统，功能简单，前期开发成本低，周期短。
- 每个子系统可按需伸缩。
- 每个子系统可采用不同的技术。

缺点:
- 子系统之间存在数据冗余、功能冗余，耦合性高。
- 按需伸缩粒度不够，对同一个子系统中的不同的业务无法实现，比如订单管理和用户管理。

> 实际上还是多个单体连在一起。

### 微服务架构

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210926201848.png)

特点:
- 服务层按业务拆分为一个一个的微服务。
- 微服务的职责单一。
- 微服务之间采用 RestFul、RPC 等轻量级协议传输。
- 有利于采用前后端分离架构。

优点:
- 服务拆分粒度更细，有利于资源重复利用，提供开发效率。
- 可以更加精准的指定每个服务的优化方案，按需伸缩。
- 适用于互联网时代，产品迭代周期更短。

缺点:
- 开发的复杂性增加，因为一个业务流程需要的多个微服务通过网络交互来完成。
- 微服务过多，服务治理成本高，不利于系统维护。

### 云原生架构
云 + 原生:
- 原生: 指一个服务在开发阶段就完成网络和服务治理的问题。
- 云: 这个服务基于云计算环境。

特点:
- 设计之初就以云环境为运行环境的微服务。

特点:
- 继承微服务的特点。
- 容器化。
- 动态管理。

缺点:
- 产商锁定。
- 部署复杂性。
- 框架兼容性。

> 由于docker, k8s 等容器技术的出现使云原生成为可能。

每一个新架构的出现都是为了解决上一代架构所遗留的问题，但同时又引进新的问题。*软件中没有银弹*。

## 架构演进
业务托管架构的演进。

1. 中心化。
2. 去中心化。
3. 连接/共享。
4. 虚拟机托管。
5. 云托管。
6. 细粒度复用。
7. 云原生。

### 中心化
大型机时代的特点，大型机基于中心化数据存储和计算模型，客户端终端值具备基础功能。

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210927183934.png)

### 去中心化
从大型机到服务器时代，去中心化。

特点:
- 大多数逻辑放在服务端。
- 某些处理过程放在客户端上。
- 引入面向对象设计。

但是需要为么个用户安装客户端应用，并且无法作为业务函数进行细粒度的扩展

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210927184240.png)

反模式: 非正常模式开发的代码。

### 连接/共享
cs: 客户端/服务端架构
引入三层架构: UI -> API -> DB
引入 SOA 架构

通过网络进行通讯。

从此架构的软件细分出两类: 软件和硬件

### 虚拟机托管
虚拟化技术的出现和推广使得软件业务的部署环境从物理机到虚拟机。

特点:
- 开发和运营团队不再操心服务器基础架构。
- 开发人员可以托管自定义的业务应用。

缺点: 单体地狱

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210927185040.png)

### 云托管时代

微服务
十二因子

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210927185257.png)

Paas 和 SaaS 的推广起到非常重要的作用。但过早的普及让人以为只需要将旧服务迁移到 Paas 或者 SaaS 就实现了云原生，从而带来一系列的问题。

如何解决这些问题呢: 答案就是 *微服务* 和 *十二因子* 。遵行十二因子的微服务在 PaaS 和 SaaS 中可以使收益最大化。

### 细粒度复用
微服务带来的好处。
- 使较小的团队主导特定业务和技术功能的整个开发周期。
- 可以随时部署或升级代码，而不会对系统的其他部分产生副作用。
- 微服务鼓励服务方和消费者之间以合约驱动开发工作。

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210927190243.png)

在微服务的基础上，又出现更加激进的架构: Serverless 和 Service Mesh

### 云原生

云原生的两种设计:
- 服务网格: Service Mesh
- 无服务器架构: Serverless

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210927190816.png)
![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210927190830.png)

## 架构的痛点

单体架构:
- 条件逻辑复杂
- 扩容难

分布式:
- 代码混乱
- 数据依赖

微服务:
- 代码混乱
- 服务治理

云原生:
- 单体地狱: 代码复杂高，难以修改。
- 微晶石: 不可自愈，不能伸缩的微服务。
- 死星: 设计不佳的微服务，服务拆分得太细，内部依赖关系混乱。

## 云原生架构
使用云原生时一定会和云计算和微服务搭配使用。

云原生的核心就是快: 迭代快，开发快。

### 云原生和云计算的区别
云原生不是云计算。云计算的特点是拥有资源池，资源动态伸缩，存在的目的在于提供效率，它是一种计算的资源平台。

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210927193216.png)

云原生时利用云计算的能力达到快的方法论。

### 云原生和微服务的区别

#### 1.生命周期:

微服务: 规划 -> 构建 -> 协同 -> 测试 -> 部署 -> 发布 -> 平滑 -> 运营 -> 下线

云原生: 主流都是运行在 kubernetes 平台上， 开始 -> 运行 -> 终止

#### 2.流量治理:

微服务: 微服务天生就需要一种网络治理方案，通过框架实现。

云原生: 通过 Service Mesh 接管网络处理。

#### 3.编程模型:
微服务: 请求驱动。
云原生: 通过 serverless 处理，serverless 可以将请求处理成服务可以识别的语义。

![](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20210927195031.png)

#### 4.可信安全:
微服务: 缺少可信安全验证。
云原生: 利用平台的特点在网络层面内部以应用为中心，又建设起一套基于统一省份认证授权的体系。

## 什么是云原生
云原生的方法论:
- Devops
- 持续交付
- 微服务
- 敏捷基础设施
- 十二因子