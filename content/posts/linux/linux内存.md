---
title: "Linux内存"
date: 2021-10-10T23:54:28+08:00
lastmod: 2021-10-10T23:54:28+08:00
draft: false
tags: 
 - linux
categories: 
 - 笔记
author: "Lack"
---

## 内存概论

### 虚拟内存
虚拟内存(virtual memory)是 Unix 系统中一种对内存的抽象。虚拟内存作为一种逻辑层，处于应用程序的内存请求与硬件内存管理单元(Memory Management Unit, MMU)之间。虚拟内存有很多用途和优点:
- 若干个进程可能并发地执行。
- 应用程序所需内存大于可用物理内存时也可以运行。
- 程序只有部分代码装入内存时进程可以执行它。
- 允许每个进程访问可用物理内存的子集。
- 进程可以共享库函数或程序的一个单独内存映象。
- 程序时可重定位的，也就是说，可以把程序放在物理内存的任何地方。
- 程序员可以编写与机器无关的代码，因为他们不必关心有关物理内存的组织结构。

虚拟内存子系统的主要成分是虚拟地址空间(virtual address space)的概念。进程所用的一组内存地址不同于物理内存地址。当进程使用一个虚拟地址时，内核和MMU协同定位其在内存中的实际物理地址位置。

现在的 CPU 包含了能自动把虚拟地址转换成物理地址的硬件电路。为了达到这个目标，把可用 RAM 划分成长度为 4KB 或 8KB 的页框(page frame)，并引入一组页表来指定虚拟地址与物理地址之间的对应关系。

一块连续的虚拟地址请求可以通过分配一组非连续的物理地址页框而得到满足。

### 随机访问存储器(RAM)的使用
Unix 操作系统将 RAM 划分成两部分。其中若干兆字节专门用于存放内核映象(也就是内核代码和内核静态数据结构)。RAM的其余部分通常由虚拟内存系统来处理，并且用在以下三种可能的方面:
- 满足内核对缓冲区，描述符及其他动态内存数据结构的请求。
- 满足进程对一般内存区的请求及对文件内存映射的请求。
- 借助与高速缓存从磁盘及其他缓冲设备获得较好的性能。

### 内核内存分配器
内核内存分配器(Kernel Memory Allocator, KMA)是一个子系统，它试图满足系统中部分对内存的请求。其中一些请求来自内核其他子系统，它们需要一些内核使用的内存，还有一些请求来自于用户程序的系统调用，用来增加用户进程中地址空间。一个好的 KMA 应该具有下列特点:
- 必须快。因为它由所有的内核子系统(包括中断处理程序)调用。
- 必须把内存的浪费减到最少。
- 必须努力减轻内存的碎片(fragmentation)问题。
- 必须能与其他内存管理子系统合作，以便借用和释放页框。

基于不同的算法技术实现的KMA:
- 资源图分配算法(allocator)
- 2的幂次方空闲链表
- McKusick-Karels 分配算法
- 伙伴 (Buddy) 系统
- Mach 的区域 (Zone) 分配算法
- Dynix 分配算法
- Solaris 的 Slab 分配算法

### 进程虚拟地址空间处理
进程的虚拟地址空间包括了进程可以引用的所有虚拟内存地址。内核通常用一组内存区描述符描述进程虚拟地址空间。例如，当进程通过 `exec()` 类系统调用开始某个程序执行时，内核分配给进程的虚拟地址空间有以下内存区组成。
- 程序的可执行代码。
- 程序的初始化数据。
- 程序的未初始化数据。
- 初始程序栈(即用户态栈)。
- 所需共享库的可执行代码和数据。
- 堆(由程序董太太请求的内存)。

现代 Unix 操作系统采用了请求调页(demand paging)的内存分配策略。有了请求调页，进程可以在它的页还没有在内存时就开始执行。当进程访问一个不存在的页时，MMU产生一个异常，异常处理程序找到受影响的内存区，分配一个空闲的页，并用适当的数据把啊初始化。同理，当进程通过调用 `malloc()` 或 `brk()`(由malloc()在内部调用)系统调用动态地请求内存是，内核仅仅修改进程的堆内存区的大小。只有试图引进进程的虚拟内存而产生异常时，才给进程分配页框。

虚拟地址空间也采用其他更有效的策略，如写时复制策略。例如，当一个新进程被创建时，内核仅仅把父进程的页框赋给子进程的地址空间，但是把这些页框标记为只读。一旦父或子进程修改页中的内容时，一个异常就会产生。异常处理程序把新页框赋给受影响的进程，并用原来也中的内容初始化新页框。

### 高速缓存
物理内存的一大优势就是用作磁盘和其他块设备的高速缓存。通常，在最早的 Unix 系统中就已经实现的一个策略是: 尽可能地推迟写磁盘的时间，因此，从磁盘读入内存的数据即使任何进程都不再使用它们，它们也继续留在 RAM 中。

新进程请求从磁盘读或写的数据，就是被撤销进程曾拥有的数据。当一个进程请求访问磁盘时，内核首先检查进程请求的数据是否在缓存中，如果在(把这种请求叫做缓存命中)，内核就可以为进程请求提供服务而不用访问磁盘。

`sync()` 系统调用把所有"脏"的缓冲区写入磁盘来强制磁盘同步。为了避免数据丢失，所有的操作系统都会注意周期性地把脏缓存区写回磁盘。

## 内存地址
x86微处理器的三种不同地址:
- 逻辑地址(logical address): 每一个逻辑地址都由一个段(segment)和偏移量(offset或displacement)组成，偏移量指明了从段开始的地方到实际地址之间的距离。
- 线性地址(linear address)(也称虚拟地址 virtual address): 线性地址通常用十六进制数字表示，值得范围从 0x00000000 到 0xffffffff。可以表示高达 4GB 的地址。
- 物理地址(physical address): 用于芯片级内存单元寻址。他们从微处理器的地址引脚发送到内存总线上的电信号相对应。

内存控制单元(MMU)通过分段单元(segmentation unit)的硬件电路把一个逻辑地址转换成线性地址。通过分页单元(paging unit)的硬件电路把线性地址转化成物理地址。

在多处理器系统中，所有 CPU 都共享同一内存。RAM芯片上的读和写操作必须串行执行，因此内存仲裁器(memory arbiter)的硬件电路插在总线和每个 RAM 芯片之间。其作用就是如果某个 RAM 芯片空闲，就准予一个 CPU 访问，如果该芯片忙于为另一个处理器提出的请求服务，就延迟这个 CPU 的访问。

## 硬件中的分段
80206 开始，Intel 微处理器具有两种方式执行地址转换：
- 实模式(real mode)。
- 保护模式(protected mode)。

实模式存在是处于兼容性考虑，主要还是保护模式。

### 段选择符和段寄存器
一个逻辑地址由两部分组成：一个段标识符和一个指定段内相对地址的偏移量。段标识符是一个 16 位长的字段，称为段选择符(Segment Selector)。偏移量是一个 32 位长的字段。

![图2-2: 段描述符](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20211012090918.png)

专门存放段选择符的寄存器: cs, ss, ds, es, fs 和 gs。其中3个有专门的用途:
- cs 代码段寄存器，指向包含程序指令的段。
- ss 栈段寄存器，指向包含当前程序栈的段。
- ds 数据段寄存器，指向包含静态数据或者全局数据段。

其他3个段寄存器作一般用途，可以指向任意的数据段。

cs 寄存器还有一个很重要的功能: 它含有一个两位的字段，用以指明 CPU 的当前特权级 (Current Privilege Level, CPL)。值为0代表最高优先级，为值为3代表最低优先级。Linux 只用0级和3级，分别称之为内核态和用户态。

### 段描述符
每个段由一个8字节的段描述符(Segment Descriptor)表示，它描述了段的特征。段描述符放在全局描述符表(Global Descriptor Table, GDT)或局部描述符表(Local Descriptor Table, LDT)中。

GDT 通常只有一个，在主存中的地址和大小存放在 gdtr 控制寄存器中，当前正被使用的 LDT 地址和大小放在 ldtr 控制寄存器中。

段描述符字段:
- Base
- G
- Limit
- S
- Type
- DPL
- P
- D 或 B
- AVL 标志

![2-3: 段描述符格式](https://raw.githubusercontent.com/xingyys/myblog/main/posts/images/20211013084126.png)

段选择符字段: 
- index     指定了放在 GDT 或 LDT 中的相应段描述符的入口。
- TI        TI ((Table Indicator)标志：指明段描述符是在 GDT 中 (TI=0) 或在 LDT 中(TI=1))。
- RPL       请求者特权级：当相应的段选择符装入到 cs 寄存器中时，指示出 CPU 当前的特权级；它还可以用于在访问数据段时有选择地削弱处理器的特权级。