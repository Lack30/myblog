<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xingyys 的个人博客</title>
    <link>http://blog.xingyys.tech/</link>
    <description>Recent content on Xingyys 的个人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Fri, 23 Oct 2020 14:43:08 +0800</lastBuildDate><atom:link href="http://blog.xingyys.tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于</title>
      <link>http://blog.xingyys.tech/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>http://blog.xingyys.tech/about/</guid>
      <description>暂时为空</description>
    </item>
    
    <item>
      <title>etcd的使用实例</title>
      <link>http://blog.xingyys.tech/post/etcd%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</link>
      <pubDate>Fri, 23 Oct 2020 14:43:08 +0800</pubDate>
      
      <guid>http://blog.xingyys.tech/post/etcd%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</guid>
      <description>etcd 有如下的使用场景： 服务发现（Service Discovery） 消息发布与订阅 负载均衡 分布式通知与协调 分布式锁 分布式队列 集群监控于Leade</description>
    </item>
    
    <item>
      <title>GPRC 进阶</title>
      <link>http://blog.xingyys.tech/post/grpc2/</link>
      <pubDate>Fri, 23 Oct 2020 14:40:08 +0800</pubDate>
      
      <guid>http://blog.xingyys.tech/post/grpc2/</guid>
      <description>grpc 除了提供四种请求类型之外，还支持很多高级功能：keepalive、请求重试、负载均衡、用户验证等。接下来一一介绍。 GRPC 进阶功能 每个grpc请</description>
    </item>
    
    <item>
      <title>GPRC 实战</title>
      <link>http://blog.xingyys.tech/post/grpc1/</link>
      <pubDate>Fri, 23 Oct 2020 14:38:08 +0800</pubDate>
      
      <guid>http://blog.xingyys.tech/post/grpc1/</guid>
      <description>GRPC 简介 grpc 是由 google 开发的一款开源，高性能 rpc（远程进程调用协议）使用 Protocol Buffers 作为数据交换格式。 GRPC 安装 golang 使用 grpc 要安装 grpc-go, protoc 和 对应的插件。 安装grpc-</description>
    </item>
    
    <item>
      <title>postgresql 实战一：安装和使用</title>
      <link>http://blog.xingyys.tech/post/pgsql1/</link>
      <pubDate>Fri, 23 Oct 2020 14:33:55 +0800</pubDate>
      
      <guid>http://blog.xingyys.tech/post/pgsql1/</guid>
      <description>安装 这里直接使用 docker 安装 postgresql-13 1 docker run --name postgresql13 -e POSTGRES_PASSWORD=123456 -p 54322:5432 -d postgres:13 安装成功后会绑定主机端口 54322。直接进入 postgresql13 容器，使用 pgsql。 1 2 3 4 5 6 [root@localhost ~]# docker exec -it 3e3b03e3 /bin/bash</description>
    </item>
    
    <item>
      <title>golang打包和解包</title>
      <link>http://blog.xingyys.tech/post/golang%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/</link>
      <pubDate>Fri, 15 Feb 2019 15:03:44 +0000</pubDate>
      
      <guid>http://blog.xingyys.tech/post/golang%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/</guid>
      <description>打包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 打包 func Compress(destPath, srcDir string)</description>
    </item>
    
    <item>
      <title>linux上使用udev创建裸设备</title>
      <link>http://blog.xingyys.tech/post/linux%E4%B8%8A%E4%BD%BF%E7%94%A8udev%E5%88%9B%E5%BB%BA%E8%A3%B8%E8%AE%BE%E5%A4%87/</link>
      <pubDate>Sat, 26 Jan 2019 08:28:36 +0000</pubDate>
      
      <guid>http://blog.xingyys.tech/post/linux%E4%B8%8A%E4%BD%BF%E7%94%A8udev%E5%88%9B%E5%BB%BA%E8%A3%B8%E8%AE%BE%E5%A4%87/</guid>
      <description>需求和分析 在一次项目中需要将进行oracle数据库的备份，要求在oracle机器总是能认到备份的块设备的路径以保证备份和恢复的正常。同时还需</description>
    </item>
    
    <item>
      <title>iscsi共享磁盘服务</title>
      <link>http://blog.xingyys.tech/post/iscsi%E5%85%B1%E4%BA%AB%E7%A3%81%E7%9B%98%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Sat, 26 Jan 2019 08:28:08 +0000</pubDate>
      
      <guid>http://blog.xingyys.tech/post/iscsi%E5%85%B1%E4%BA%AB%E7%A3%81%E7%9B%98%E6%9C%8D%E5%8A%A1/</guid>
      <description>iscsi简单介绍 iSCSI（Internet Small Computer System Interface，发音为/ˈаɪskʌzi/），Internet小型计算机系统接口，又</description>
    </item>
    
    <item>
      <title>配置七牛云存储外链</title>
      <link>http://blog.xingyys.tech/post/%E9%85%8D%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E5%A4%96%E9%93%BE/</link>
      <pubDate>Sat, 19 Jan 2019 19:10:51 +0000</pubDate>
      
      <guid>http://blog.xingyys.tech/post/%E9%85%8D%E7%BD%AE%E4%B8%83%E7%89%9B%E4%BA%91%E5%AD%98%E5%82%A8%E5%A4%96%E9%93%BE/</guid>
      <description>今天重新整理了下博客，发现之前配置好的七牛云图片显示错误。重新配置的同时也记录下配置步骤。 添加域名 登录七牛云的官网融合CDN，在“域名管理”</description>
    </item>
    
    <item>
      <title>CentOS下kvm安装</title>
      <link>http://blog.xingyys.tech/post/centos%E4%B8%8Bkvm%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 30 Jun 2018 16:16:02 +0000</pubDate>
      
      <guid>http://blog.xingyys.tech/post/centos%E4%B8%8Bkvm%E5%AE%89%E8%A3%85/</guid>
      <description>注：运行kvm保证机器支持虚拟化且在bios中开启。 准备工作 清除iptables规则 1 2 3 4 # CentOS6 service iptables stop; service iptables save # CentOS7 systemctl stop firewalld 关闭selinux 1 2</description>
    </item>
    
    <item>
      <title>搭建lnmp环境</title>
      <link>http://blog.xingyys.tech/post/lnmp/</link>
      <pubDate>Thu, 31 May 2018 09:57:17 +0000</pubDate>
      
      <guid>http://blog.xingyys.tech/post/lnmp/</guid>
      <description>lnmp即：nginx + mysql + php 与lamp不同的是，lnmp的php不在只是httpd中的一个库，lnmp架构中php作为一个服务，专门解析p</description>
    </item>
    
    <item>
      <title>搭建lamp环境</title>
      <link>http://blog.xingyys.tech/post/lamp/</link>
      <pubDate>Thu, 31 May 2018 09:13:23 +0000</pubDate>
      
      <guid>http://blog.xingyys.tech/post/lamp/</guid>
      <description>lamp即 apache + mysql + php，是互联网常用架构。 要注意的是php依赖apache和mysql，所以要最后安装。系统环境为CentOS6.5 安装m</description>
    </item>
    
    <item>
      <title>python装饰器</title>
      <link>http://blog.xingyys.tech/post/python%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Sat, 31 Mar 2018 19:55:04 +0000</pubDate>
      
      <guid>http://blog.xingyys.tech/post/python%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>简单的装饰器函数： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time from functools import wraps def timethis(func): &amp;#34;&amp;#34;&amp;#34; Decorator that reports the execution time. &amp;#34;&amp;#34;&amp;#34; @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(func.__name__, end-start) return result return wrapper 函数的功能很简单，就</description>
    </item>
    
  </channel>
</rss>
