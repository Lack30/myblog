<!DOCTYPE html>
<html lang="en">

<head>
	<meta name="generator" content="Hugo 0.87.0" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title class="pjax-title">lack 的个人博客</title><meta name="Description" content=""><meta property="og:title" content="lack 的个人博客" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://xingyys.tech/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="lack 的个人博客"/>
<meta name="twitter:description" content=""/>
<meta name="application-name" content="lack 的个人博客">
<meta name="apple-mobile-web-app-title" content="lack 的个人博客">

<meta name="theme-color" content="#ffffff"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="http://xingyys.tech/" /><link rel="alternate" href="/index.xml" type="application/rss+xml" title="lack 的个人博客">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="lack 的个人博客"><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
    <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
    <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "http:\/\/xingyys.tech\/","inLanguage": "en","name": "lack 的个人博客"
    }
    </script></head>

<body header-desktop="" header-mobile=""><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme);}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('' === 'light' || '' === 'dark' || '' === 'black') setTheme(''), saveTheme(''); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let themeColorMeta = getMeta('theme-color');
        if (document.body.getAttribute('theme') != 'light') themeColorMeta.content = '#000000';
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="lack 的个人博客">lack 的个人博客</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="/about/" title="关于"> 关于 </a><span class="menu-item delimiter"></span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="lack 的个人博客">lack 的个人博客</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="/about/" title="关于">关于</a><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="page home" posts><div class="home-profile"></div>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/pgsql%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/">postgresql 实战一：安装和使用</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-10-13">2020-10-13</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="far fa-folder fa-fw"></i>数据库</a></span></div><div class="content">安装 这里直接使用 docker 安装 postgresql-13
docker run --name postgresql13 -e POSTGRES_PASSWORD=123456 -p 54322:5432 -d postgres:13 安装成功后会绑定主机端口 54322。直接进入 postgresql13 容器，使用 pgsql。
[root@localhost ~]# docker exec -it 3e3b03e3 /bin/bash root@3e3b03e3e442:/# psql -h localhost -p 5432 -U postgres psql (13.0 (Debian 13.0-1.pgdg100+1)) Type &#34;help&#34; for help. postgres=# psql 是 pgsql 的客户端命令，使用参数如下：
 -h：指定 pgsql 的地址 -p：指定 pgsql 的绑定端口 -U：指定登录的用户名，默认为 postgres。后面可以紧接 &ldquo;database&rdquo;，直接进入指定的数据库。   数据库的操作 postgresql 支持的数据库操作有 增、删、查、改 创建数据库 创建数据库的命令为： create database &lt;databasename&gt; [encoding 'UTF-8'] postgres=#createdatabasetestencoding&#39;UTF-8&#39;;CREATEDATABASE查询数据库 查询数据库的命令有两种：第一种是 \l ，只能在 psql 中使用：</div><div class="post-footer">
        <a href="/posts/pgsql%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/postgresql/">postgreSQL</a>,&nbsp;<a href="/tags/database/">database</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/">Golang跨平台编译</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-09-10">2020-09-10</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E9%9A%8F%E7%AC%94/"><i class="far fa-folder fa-fw"></i>随笔</a></span></div><div class="content">golang cgo 到 Windows 的交叉编译 本篇记录在 MaxOS 下 cgo 交叉编译的解决方案。因为在项目中使用 go-sqlite3 ，编译 go-sqlite3 中需要使用到 cgo。在 MacOS 下编译 Go 原生 Linux 和 Windows 的程序使用以下命令：
# 交叉编译到 linux GOOS=linux GOARCH=amd64 go build main.go # 交叉编译到 windows GOOS=windows GOARCH=amd64 go build -o main.exe main.go 如果使用 cgo 的话，还需要添加 CGO_ENABLED 参数：
CGO_ENABLED=1 GOOS=windows GOARCH=amd64 go build -o main.exe main.go 但是这种编译 go-sqlite3 的代码会出现以下错误：
# runtime/cgo gcc_libinit_windows.c:7:10: fatal error: &#39;windows.h&#39; file not found 因为 Windows 中使用 MinGW，MacOS 下如果交叉编译需要安装 C/C++ 交叉编译工具：</div><div class="post-footer">
        <a href="/posts/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/golang/">golang</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/scst%E7%BB%93%E5%90%88fc/">Scst结合FC</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-08-06">2020-08-06</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E8%BF%90%E7%BB%B4/"><i class="far fa-folder fa-fw"></i>运维</a></span></div><div class="content">SCST 是 iscsi 的一种实现方式，它既可以使用 iscsi 协议共享本地磁盘，同时也支持 FC 协议。FC 协议需要硬件 FC HBA 卡的支持。 SCST 和 FC 的环境搭建如下看这里 。
环境配置 接下来 SCST 和 FC 的使用。首先需要有 scst 的环境： 保证 linux 内核中加载了 qla。使用 scstadm 查看所支持的驱动：如果使用 FC 去共享磁盘，scst 需要创建和 FC 设备对应的 target。FC 设备和 target 属于一对一关系，而且创建 target 的名称要和 FC 设备的 ID 相同。查看 FC 设备的 ID 可以用以下的方式：1.查看内核中 qla2x00t (/sys/kernel/scst_tgt/targets/qla2x00t) 目录下的内容2.直接查看 FC 设备的 port_id (/sys/class/fc_host/hostx/port_name)，配置 FC SCST 服务端配置 创建 target, FC 设备和 target 一对一。
scstadmin -add_target 50:01:10:a0:00:16:bf:30 -driver qla2x00t 创建 device 对应本地的块文件</div><div class="post-footer">
        <a href="/posts/scst%E7%BB%93%E5%90%88fc/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/iscsi/">iscsi</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/grpc1/">GPRC 实战</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-07-31">2020-07-31</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><i class="far fa-folder fa-fw"></i>微服务</a>&nbsp;<a href="/categories/%E4%BB%A3%E7%A0%81/"><i class="far fa-folder fa-fw"></i>代码</a></span></div><div class="content">GRPC 简介 grpc 是由 google 开发的一款开源，高性能 rpc（远程进程调用协议）使用 Protocol Buffers 作为数据交换格式。
GRPC 安装 golang 使用 grpc 要安装 grpc-go, protoc 和 对应的插件。安装grpc-go go get -u github.com/golang/protobuf/{proto,protoc-gen-go} go get -u google.golang.org/grpc 如果是国内用户无法连接到 google.golang.org 的话可以使用 VPN。或者直接从 github.com 直接下载源代码再编译安装git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc go get -u google.golang.org/grpc 安装 protoc golang 要使用 grpc，还需要使用 protoc 工具。因为 golang 不能直接识别 .proto 文件，需要使用 protoc 工具将 .proto 转化成 golang 代码。下面介绍几个平台下安装 protobuf 的方法。macos macos 下安装直接使用 brew 命令即可。brew install protobuf linux linux 下需要先从 github.com 下载 protobuf 源码或者二进制文件，下载地址。二进制安装的话就下载 protobuf-all-*.</div><div class="post-footer">
        <a href="/posts/grpc1/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/golang/">golang</a>,&nbsp;<a href="/tags/grpc/">grpc</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/grpc2/">GPRC 进阶</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-07-31">2020-07-31</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"><i class="far fa-folder fa-fw"></i>微服务</a>&nbsp;<a href="/categories/%E4%BB%A3%E7%A0%81/"><i class="far fa-folder fa-fw"></i>代码</a></span></div><div class="content">grpc 除了提供四种请求类型之外，还支持很多高级功能：keepalive、请求重试、负载均衡、用户验证等。接下来一一介绍。GRPC 进阶功能  每个grpc请求都是 stream。
 Keepalive Keepalive 能够让 grpc 的每个 stream 保持长连接状态，适合一些执行时间长的请求。Keepalive 支持在服务端和客户端配置，且只有服务端配置后，客户端的配置才会真正有效。先给出实例的代码在来说明 grpc keepalive 的使用情况：server 实现：// ... var kaep = keepalive.EnforcementPolicy{ MinTime: 5 * time.Second, // If a client pings more than once every 5 seconds, terminate the connection 	PermitWithoutStream: true, // Allow pings even when there are no active streams } var kasp = keepalive.ServerParameters{ MaxConnectionIdle: 15 * time.Second, // If a client is idle for 15 seconds, send a GOAWAY 	MaxConnectionAge: 30 * time.</div><div class="post-footer">
        <a href="/posts/grpc2/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/golang/">golang</a>,&nbsp;<a href="/tags/grpc/">grpc</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/scst%E5%9C%A8%E7%BA%BF%E6%89%A9%E5%AE%B9/">Scst在线扩容</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-04-09">2020-04-09</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E8%BF%90%E7%BB%B4/"><i class="far fa-folder fa-fw"></i>运维</a></span></div><div class="content">SCST 共享的磁盘支持在线扩容。操作如下： scst 服务端 首先有一块 zfs 存储卷，现在将其容量从 15G 扩展到 20G。
zfs set volsize=20G tank/vol 修改 scst 中 device 的 size 属性
scstadmin -set_dev_attr device1 -attributes size=21474836480 -noprompt iscsi 客户端 重新扫描 target
iscsiadm -m node --target &lt;target_name&gt; -R 扩展磁盘容量，如果磁盘存储 mount 状态则先 umount。
resize2fs /dev/sdX e2fsck -f /dev/sdX resize2fs /dev/sdX 重新挂载，使用 df 即可发现磁盘的容量被修改。 FC 客户端 重新扫描 FC host
echo &#34;- - -&#34; &gt; /sys/class/scst_host/hostX/scan 扩展磁盘容量如上。</div><div class="post-footer">
        <a href="/posts/scst%E5%9C%A8%E7%BA%BF%E6%89%A9%E5%AE%B9/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/iscsi/">iscsi</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/scst%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/">Scst 安装和使用</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-04-08">2020-04-08</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E8%BF%90%E7%BB%B4/"><i class="far fa-folder fa-fw"></i>运维</a></span></div><div class="content">安装 scst 安装 scst
wget https://ncu.dl.sourceforge.net/project/scst/scst-3.2.0.7058.tar.bz2 yum install bzip2 bunzip2 scst-3.2.0.7058.tar.bz2 tar xf scst-3.2.0.7058.tar 编译安装scst
make 2perf make scst make scst_install make iscsi make iscsi_install make scstadm make scstadm_install 查看是否被加载到内核了
lsmod |grep scst modinfo scst 启动 scst
modprobe scst modprobe scst_vdisk modprobe scst_disk modprobe scst_user modprobe scst_modisk modprobe scst_processor modprobe scst_raid modprobe scst_tape modprobe scst_cdrom modprobe scst_changer modprobe iscsi-scst iscsi-scstd 创建流程 创建 target
scstadmin -add_target iqn.1994-05.com.redhat:pv -driver iscsi 创建 block</div><div class="post-footer">
        <a href="/posts/scst%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/iscsi/">iscsi</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/%E5%AE%89%E8%A3%85oh-my-zsh/">linux 安装 oh-my-zsh</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2020-02-09">2020-02-09</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E5%85%B6%E4%BB%96/"><i class="far fa-folder fa-fw"></i>其他</a></span></div><div class="content">一、介绍 oh-my-zsh 是一款命令行工具，在zsh的基础上添加了许多的新功能。接下来就来安装并使用他。二、安装 oh-my-zsh oh-my-zsh 是在 zsh 的基础上使用的，所以要就安装zsh。一般linux发行版默认使用bash。以下环境为CentOS7。使用 yum 安装 zsh
$ yum install zsh 安装完成后，替换默认的 bash 为 zsh。需要在 root 用户下使用
$ chsh -s /bin/zsh Changing shell for root. Shell changed. # 在新终端中验证 $ echo $SHELL /bin/zsh 执行以下命令自动安装 oh-my-zsh
$ wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh # 省略输出... $ source .zshrc # .zshrc 为 zsh 的配置文件 三、配置 oh-my-zsh 接下来还要添加额外的功能。oh-my-zsh 支持很多强大的功能，这些功能都是以插件的方式实现。插件放在目录~/.oh-my-zsh/plugins 下。要让插件开始工作还需要在 .zshrc 中配置相关参数。
plugins=(git textmate ruby autojump osx mvn gradle) autojump 作用目录间快速跳转,不用再一直 cd 了 😁**使用 **使用 autojump 的缩写 jcd 命令进入 ~/user/github/Youthink 文件夹，下一次再想进入 Yourhink 文件夹的时候,直接 j youthink 即可, 或者只输入 youthink 的一部分 youth 都行删除无效路径</div><div class="post-footer">
        <a href="/posts/%E5%AE%89%E8%A3%85oh-my-zsh/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/linux/">linux</a>,&nbsp;<a href="/tags/%E7%BB%88%E7%AB%AF/">终端</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/aix1/">Aix添加和删除Iscsi存储卷</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2019-10-22">2019-10-22</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E9%9A%8F%E7%AC%94/"><i class="far fa-folder fa-fw"></i>随笔</a></span></div><div class="content">Aix为6.1版本
 使用iscsi存储 首先需要创建一个iscsi target，并共享到IBM Aix上。
检查iscsi是否被安装 $ lslpp -L | grep -i iscsi devices.common.IBM.iscsi.rte 6.1.5.0 C F Common iSCSI Files devices.iscsi.disk.rte 6.1.5.0 C F iSCSI Disk Software ... 配置iscsi $ vi /etc/iscsi/targets ... # 添加target 172.16.1.169 3260 iqn.2018-11.com.howlink.wbrt.portal.backup 重新扫盘 $ cfgmgr -l iscsi0 cfgmgr: 0514-621 WARNING: The following device packages are required for device support but are not currently installed. devices.iscsi.array 查看iscsi盘 $ lsdev -Cc disk | grep iSCSI hdisk18 Available Other iSCSI Disk Drive 创建物理卷 $ chdev -l hdisk18 -a pv=yes 创建vg $ mkvg -y wbrt_portal_bg hdisk18 创建lv $ mklv -t jfs2 -y wbrt_portal_bl wbrt_portal_bg 700  注:lv的大小可以使用命令 $ lsvg wbrt_portal_bg | grep &quot;TOTAL PPs&quot; | awk -F' ' '{ print $6}' 703 但不要全部使用，需要一些剩余空间。</div><div class="post-footer">
        <a href="/posts/aix1/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/aix/">aix</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/%E4%BD%BF%E7%94%A8kubeadm%E5%AE%89%E8%A3%85kubernetes1.16/">使用kubeadm安装kubernetes1.16</a>
    </h1><div class="post-meta">
        <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">作者</a>
        </span>&nbsp;<span class="post-publish">发布于 <time datetime="2019-10-19">2019-10-19</time></span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"><i class="far fa-folder fa-fw"></i>云计算</a></span></div><div class="content">环境版本说明：
 三台vmware虚拟机，系统版本CentOS7.6。 Kubernetes 1.16.0，当前最新版。 flannel v0.11 docker 18.09  使用kubeadm可以简单的搭建一套k8s集群环境，而不用关注安装部署的细节，而且现在k8s的版本更新频率很快，所以这种方法十分推荐。
相关准备  注：本节相关操作要在所有节点上执行。
 硬件环境 使用三台vmware虚拟机，配置网络，并保证可以联网。
 k8s-master 4G 4核 CentOS7 192.168.10.20 k8s-node1 2G 2核 CentOS7 192.168.10.21 k8s-node2 2G 2核 CentOS7 192.168.10.22  主机划分  k8s-master作为集群管理节点：etcd kubeadm kube-apiserver kube-scheduler kube-controller-manager kubelet flanneld docker k8s-node1作为工作节点：kubeadm kubelet flanneld docker k8s-node2作为工作节点：kubeadm kubelet flanneld docker  准备工作 安装必要的rpm软件：
yum install -y wget vim net-tools epel-release 关闭防火墙
systemctl disable firewalld systemctl stop firewalld 关闭selinux</div><div class="post-footer">
        <a href="/posts/%E4%BD%BF%E7%94%A8kubeadm%E5%AE%89%E8%A3%85kubernetes1.16/">阅读全文</a><div class="post-tags">
                <i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/k8s/">k8s</a></div></div>
</article><ul class="pagination"><li class="page-item ">
                    <span class="page-link">
                        <a href="/">1</a>
                    </span>
                </li><li class="page-item active">
                    <span class="page-link">
                        <a href="/page/2/">2</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/3/">3</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/4/">4</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/5/">5</a>
                    </span>
                </li></ul></div></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.87.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer" title="DoIt 0.2.10"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank" rel="noopener noreferrer"></a></span></div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/topbar/topbar.min.js"></script><script type="text/javascript" src="/lib/pjax/pjax.min.js"></script><script type="text/javascript" src="/js/theme.min.js"></script></div>

<div class="pjax-assets"><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10}};</script></div>
</body>

</html>