<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>python - 标签 - lack 的个人博客</title>
        <link>http://xingyys.tech/tags/python/</link>
        <description>python - 标签 - lack 的个人博客</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 31 Mar 2018 19:55:04 &#43;0000</lastBuildDate><atom:link href="http://xingyys.tech/tags/python/" rel="self" type="application/rss+xml" /><item>
    <title>python装饰器</title>
    <link>http://xingyys.tech/posts/python/python%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
    <pubDate>Sat, 31 Mar 2018 19:55:04 &#43;0000</pubDate><author>
        <name>作者</name>
    </author><guid>http://xingyys.tech/posts/python/python%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
    <description><![CDATA[简单的装饰器函数： import time from functools import wraps def timethis(func): &#34;&#34;&#34; Decorator that reports the execution time. &#34;&#34;&#34; @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) end = time.time() print(func.__name__, end-start) return result return wrapper 函数的功能很简单，就是输出调用函数的执行时间。
In [2]: @timethis ...: def countdown(n): ...: while n &gt; 0: ...: n -= 1 ...: In [3]: countdown(100000) countdown 0.009751319885253906 本质上来说python的装饰器就是一个函数外再包装一个函数，等同于：
timethis(countdown(100000)) 装饰器内部的wrapper()函数中使用*args和**kwargs来接受任意参数，并用新的函数包装器来代替原来函数，其中的func就是原来的函数，即调用包装器的函数。而使用@wraps(func)的目的时保留原始函数的元数据。
In [19]: @timethis ...: def countdown(n:int): ...: &#39;&#39;&#39;counts down&#39;&#39;&#39; .]]></description>
</item></channel>
</rss>
