<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>C&#43;&#43; - 标签 - lack 的个人博客</title>
        <link>http://xingyys.tech/tags/c&#43;&#43;/</link>
        <description>C&#43;&#43; - 标签 - lack 的个人博客</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 11 May 2019 16:41:20 &#43;0800</lastBuildDate><atom:link href="http://xingyys.tech/tags/c&#43;&#43;/" rel="self" type="application/rss+xml" /><item>
    <title>C&#43;&#43;友元</title>
    <link>http://xingyys.tech/posts/clang/c&#43;&#43;%E5%8F%8B%E5%85%83/</link>
    <pubDate>Sat, 11 May 2019 16:41:20 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/clang/c&#43;&#43;%E5%8F%8B%E5%85%83/</guid>
    <description><![CDATA[友元说明 相对于其他的编程语言，“友元”是C++中特别的一种语法。那它有什么作用呢？ 其实“友元”就是提供一种访问类私有部分的的方法。如果没有“友元”，我们只能通过类本身提供的公有方法来访问，但相对地，这样限制太高了，所以“友元”就是一种的在类的封装性和实用性中很好的“折中”方式。
C++中的友元有三种：
 友元函数 友元类 友元成员函数  C++中使用关键字friend来定义。
友元函数 这里直接用代码来说明：
#include &lt;iostream&gt;#include &lt;string&gt; class Person { private: std::string account; std::string passwd; public: Person(std::string ac, std::string pw); // 这里使用friend关键字，指定Point中的getPerson方法可以使用Person类的私有变量。  friend void getPerson(Person &amp;p); }; Person::Person(std::string ac, std::string pw) { account = ac; passwd = pw; } void getPerson(Person &amp;p) { // 因为定义了友元，这里就可以访问Person类的私有变量了。  std::cout &lt;&lt; &#34;account: &#34; &lt;&lt; p.account &lt;&lt; &#34;, passwd: &#34; &lt;&lt; p.passwd &lt;&lt; std::endl; } int main() { Person p(&#34;xingyys&#34;, &#34;123456&#34;); getPerson(p); return 0; } 这个例子还是比较简单的，只要在指定的方法中添加关键字就可以实现了。]]></description>
</item></channel>
</rss>
