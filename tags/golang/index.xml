<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>golang - 标签 - lack 的个人博客</title>
        <link>http://xingyys.tech/tags/golang/</link>
        <description>golang - 标签 - lack 的个人博客</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 10 Jan 2021 14:34:22 &#43;0800</lastBuildDate><atom:link href="http://xingyys.tech/tags/golang/" rel="self" type="application/rss+xml" /><item>
    <title>分布式的工作流实现</title>
    <link>http://xingyys.tech/posts/linux/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E7%8E%B0/</link>
    <pubDate>Sun, 10 Jan 2021 14:34:22 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/linux/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E7%8E%B0/</guid>
    <description><![CDATA[本篇提供一个实现分布式工作流的思路。
系统组成部分：
 api (网关接口) : 为用户提供工作流的api接口 discovery (服务发现) : 用于服务的注册和发现 scheduler (调度中心) : 整体工作流的调度 broker (消息队列) : 订阅发布和数据传输 node (工作节点) : 每个工作单元的提供者和执行者  实现思路：
 node 启动时上传每个工作单元的基本信息: 包含工作单元输入输出、名称及其他内容 scheduler 保存这些信息并提供显示 scheduler 接收来自前端的数据并转化成工作流的信息，并执行  实现细节：
 scheduler 动态生成工作流信息，在 broker 中启动 topic 一个订阅者接收工作流的动态信息 scheduler 根据工作单元信息寻找 node 并传输信息 node 执行对应的工作单元发布信息到 broker 中工作流 topic scheduler 接收 topic 中的信息，如果中间发生错误，执行回滚操作 node 需要的输入参数保存在 context.Context 中，返回参数则 publish 到 topic 中  // 工作单元的接口 type WorkUnit interface { Do(ctx) error Undo(ctx) error String() string } type workflow struct{ units []WorkUnit } func Builder(ctx context.]]></description>
</item><item>
    <title>Golang监控进程流量</title>
    <link>http://xingyys.tech/posts/go/golang%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E6%B5%81%E9%87%8F/</link>
    <pubDate>Sat, 09 Jan 2021 17:06:14 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/go/golang%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E6%B5%81%E9%87%8F/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>Windows 上使用 Go 语言</title>
    <link>http://xingyys.tech/posts/go/windows%E4%B8%8A%E4%BD%BF%E7%94%A8go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</link>
    <pubDate>Thu, 29 Oct 2020 16:44:06 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/go/windows%E4%B8%8A%E4%BD%BF%E7%94%A8go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91/</guid>
    <description><![CDATA[在 Windows 使用 Go 开发项目是，为了实现统一的配置和格式管理，需要进行一下的配置。
开发环境选择 Go 语言的开发环境统一使用 Jetbrain 公司的 Goland。之后需要进行一些配置。 修改统一的文件换行符为 \n 。 settings &gt; Editor &gt; Code Style 添加格式化工具 goimports。goimports 同时内置了 gofmt 的功能。可以格式化 Go 代理、自动导入依赖包等。 settings &gt; Editor &gt; Code Style &gt; Go 设置文件自动格式化 settings &gt; Tools &gt; File Watch 配置远程主机代码同步（可选）
Tools &gt; Deployment &gt; Configuration Git 配置 文本文件所使用的换行符，在不同的系统平台上是不一样的。 UNIX/Linux 使用的是 0x0A（LF） ，早期的 Mac OS 使用的是 0x0D（CR） ，后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS/Windows 一直使用 0x0D0A（CRLF） 作为换行符。
跨平台协作开发是常有的，不统一的换行符确实对跨平台的文件交换带来了麻烦。最大的问题是，在不同平台上，换行符发生改变时，Git 会认为整个文件被修改，这就造成我们没法 diff，不能正确反映本次的修改。还好 Git 在设计时就考虑了这一点，其提供了一个 autocrlf 的配置项，用于在提交和检出时自动转换换行符，该配置有三个可选项：]]></description>
</item><item>
    <title>Golang跨平台编译</title>
    <link>http://xingyys.tech/posts/go/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</link>
    <pubDate>Thu, 10 Sep 2020 14:52:46 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/go/golang%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91/</guid>
    <description><![CDATA[golang cgo 到 Windows 的交叉编译 本篇记录在 MaxOS 下 cgo 交叉编译的解决方案。因为在项目中使用 go-sqlite3 ，编译 go-sqlite3 中需要使用到 cgo。在 MacOS 下编译 Go 原生 Linux 和 Windows 的程序使用以下命令：
# 交叉编译到 linux GOOS=linux GOARCH=amd64 go build main.go # 交叉编译到 windows GOOS=windows GOARCH=amd64 go build -o main.exe main.go 如果使用 cgo 的话，还需要添加 CGO_ENABLED 参数：
CGO_ENABLED=1 GOOS=windows GOARCH=amd64 go build -o main.exe main.go 但是这种编译 go-sqlite3 的代码会出现以下错误：
# runtime/cgo gcc_libinit_windows.c:7:10: fatal error: &#39;windows.h&#39; file not found 因为 Windows 中使用 MinGW，MacOS 下如果交叉编译需要安装 C/C++ 交叉编译工具：]]></description>
</item><item>
    <title>GPRC 实战</title>
    <link>http://xingyys.tech/posts/go/grpc1/</link>
    <pubDate>Fri, 31 Jul 2020 14:38:08 &#43;0800</pubDate><author>
        <name>作者</name>
    </author><guid>http://xingyys.tech/posts/go/grpc1/</guid>
    <description><![CDATA[GRPC 简介 grpc 是由 google 开发的一款开源，高性能 rpc（远程进程调用协议）使用 Protocol Buffers 作为数据交换格式。
GRPC 安装 golang 使用 grpc 要安装 grpc-go, protoc 和 对应的插件。
安装grpc-go go get -u github.com/golang/protobuf/{proto,protoc-gen-go} go get -u google.golang.org/grpc 如果是国内用户无法连接到 google.golang.org 的话可以使用 VPN。或者直接从 github.com 直接下载源代码再编译安装
git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc go get -u google.golang.org/grpc 安装 protoc golang 要使用 grpc，还需要使用 protoc 工具。因为 golang 不能直接识别 .proto 文件，需要使用 protoc 工具将 .proto 转化成 golang 代码。下面介绍几个平台下安装 protobuf 的方法。
macos macos 下安装直接使用 brew 命令即可。
brew install protobuf linux linux 下需要先从 github.]]></description>
</item><item>
    <title>GPRC 进阶</title>
    <link>http://xingyys.tech/posts/go/grpc2/</link>
    <pubDate>Fri, 31 Jul 2020 14:38:08 &#43;0800</pubDate><author>
        <name>作者</name>
    </author><guid>http://xingyys.tech/posts/go/grpc2/</guid>
    <description><![CDATA[grpc 除了提供四种请求类型之外，还支持很多高级功能：keepalive、请求重试、负载均衡、用户验证等。接下来一一介绍。
GRPC 进阶功能  每个grpc请求都是 stream。
 Keepalive Keepalive 能够让 grpc 的每个 stream 保持长连接状态，适合一些执行时间长的请求。Keepalive 支持在服务端和客户端配置，且只有服务端配置后，客户端的配置才会真正有效。先给出实例的代码在来说明 grpc keepalive 的使用情况：server 实现：
// ... var kaep = keepalive.EnforcementPolicy{ MinTime: 5 * time.Second, // If a client pings more than once every 5 seconds, terminate the connection 	PermitWithoutStream: true, // Allow pings even when there are no active streams } var kasp = keepalive.ServerParameters{ MaxConnectionIdle: 15 * time.Second, // If a client is idle for 15 seconds, send a GOAWAY 	MaxConnectionAge: 30 * time.]]></description>
</item><item>
    <title>etcd的使用实例</title>
    <link>http://xingyys.tech/posts/linux/etcd%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</link>
    <pubDate>Wed, 11 Sep 2019 15:17:42 &#43;0800</pubDate><author>
        <name>作者</name>
    </author><guid>http://xingyys.tech/posts/linux/etcd%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</guid>
    <description><![CDATA[etcd 有如下的使用场景：
 服务发现（Service Discovery） 消息发布与订阅 负载均衡 分布式通知与协调 分布式锁 分布式队列 集群监控于Leader竞选。  一、服务发现 etcd 的常见使用场景之一就是服务发现。实现思路如下：先准备 etcd 服务端，服务端的程序在第一次启动之后会连接到 etcd 服务器并设置一个格式为 ip:port 的键值对，并绑定一个 lease。之后的服务端内部维护一个定时器，每隔一段时间就更新服务端注册中心的 lease 的 TTL。另外一个组件就是服务发现组件，discovery 会 watch 服务端的 key。每次该 key 变化时，discovery 就可以检测到时间并做出对应的操作。代码的实现如下：
// server.go package main import ( &#34;context&#34; &#34;crypto/md5&#34; &#34;encoding/json&#34; &#34;errors&#34; &#34;flag&#34; &#34;fmt&#34; &#34;github.com/coreos/etcd/clientv3&#34; &#34;github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes&#34; &#34;log&#34; &#34;net&#34; &#34;os&#34; &#34;os/signal&#34; &#34;strings&#34; &#34;syscall&#34; &#34;time&#34; ) var ( prefix = &#34;register&#34; client *clientv3.Client stopSignal = make(chan struct{}, 1) srvKey string ) var ( serv = flag.]]></description>
</item><item>
    <title>Go 结合 etcd</title>
    <link>http://xingyys.tech/posts/go/go%E7%BB%93%E5%90%88etcd/</link>
    <pubDate>Tue, 10 Sep 2019 15:17:42 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/go/go%E7%BB%93%E5%90%88etcd/</guid>
    <description><![CDATA[关于 etcd 的安装和介绍看 这里 。官方的实例可以看 这里
一、连接 首先是关于 golang 如何连接 etcd ，先是简单的连接。
package main import ( &#34;github.com/coreos/etcd/clientv3&#34; &#34;log&#34; &#34;time&#34; ) func connect() { cli, err := clientv3.New(clientv3.Config{ // etcd 集群的地址集合 	Endpoints: []string{&#34;192.168.10.10:2379&#34;}, // 请求超时时间 	DialTimeout: time.Second * 3, }) if err != nil { log.Fatal(&#34;connect etcd cluster: &#34; + err.Error()) } cli.Close() } 还有带 https 和 开启用户验证的连接
func connectTlsAuth() { tlsInfo := transport.TLSInfo{ CertFile: &#34;/tmp/cert.pem&#34;, KeyFile: &#34;/tmp/key.pem&#34;, TrustedCAFile: &#34;/tmp/ca.]]></description>
</item><item>
    <title>Golang使用json格式实现增删查改</title>
    <link>http://xingyys.tech/posts/go/golang%E4%BD%BF%E7%94%A8json%E6%A0%BC%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/</link>
    <pubDate>Wed, 07 Aug 2019 16:43:13 &#43;0800</pubDate><author>
        <name>Lack</name>
    </author><guid>http://xingyys.tech/posts/go/golang%E4%BD%BF%E7%94%A8json%E6%A0%BC%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9/</guid>
    <description><![CDATA[需求和思路 在一般的小项目或者一个小软件,例如客户端之类的小程序中,可能会需要数据的持久化.但是使用一般的数据库(Mysql)之类的不合适.使用sqlite3这种嵌入式的是个较好的方法,但是Go语言中sqlite3的库是C语言的,Cgo不支持跨平台编译.正是由于这种需求,才想到使用json格式将数据直接保存在文件中. 具体的思路是怎么样呢? 在Go语言中如果要将数据转化成json格式的话,有两种格式 struct 和 map. 如果同时需要增删查改功能的话,将map作为中间格式是比较合适的.接下来我们就来实现它.
查询操作 这种操作的实现比较简单,直接将文件中的数据读取出来,使用json库反序列化就可以了. 代码如下 :
type Product struct { Name string `json:&#34;name&#34;` Num int `json:&#34;num&#34;` } func findAll() { ps := make([]Product, 0) data, err := ioutil.ReadFile(&#34;./index.json&#34;) if err != nil { log.Fatal(err) } // 这里参数要指定为变量的地址 	err = json.Unmarshal(data, &amp;ps) if err != nil { log.Fatal(err) } fmt.Println(ps) } 添加操作 添加的实现实在查询的基础上的,我们需要先查询文件中的数据库,并转化为map格式,再将struct也转化为map格式(这里要使用反射),合并map,json序列化,最后保存在文件中.代码如下:
func create() { fields := make([]map[string]interface{}, 0) p1 := &amp;Product{ Name: &#34;Blog&#34;, Num: 2, } _, _ = json.]]></description>
</item><item>
    <title>golang打包和解包</title>
    <link>http://xingyys.tech/posts/go/golang%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/</link>
    <pubDate>Fri, 15 Feb 2019 15:03:44 &#43;0000</pubDate><author>
        <name>作者</name>
    </author><guid>http://xingyys.tech/posts/go/golang%E6%89%93%E5%8C%85%E5%92%8C%E8%A7%A3%E5%8C%85/</guid>
    <description><![CDATA[打包 // 打包 func Compress(destPath, srcDir string) error { // 压缩文件路径 	fw, err := os.Create(destPath) if err != nil { return err } defer fw.Close() // gzip writer 	gw := gzip.NewWriter(fw) defer gw.Close() // tar writer 	tw := tar.NewWriter(gw) defer tw.Close() // 读取要压缩的目录 	dir, err := os.Open(srcDir) if err != nil { return err } defer dir.Close() // 读取目录内容 	files, err := dir.Readdir(0) if err !]]></description>
</item></channel>
</rss>
